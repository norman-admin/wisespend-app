<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing - TemporalManager</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f8fafc;
        }
        
        .test-container {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        .test-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid #e5e7eb;
        }
        
        .test-title {
            font-size: 24px;
            font-weight: 700;
            color: #1f2937;
            margin: 0;
        }
        
        .test-section {
            margin-bottom: 24px;
        }
        
        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
            padding: 8px 16px;
            background: #f3f4f6;
            border-radius: 8px;
        }
        
        .test-button {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            margin: 4px 8px 4px 0;
            transition: background-color 0.2s;
        }
        
        .test-button:hover {
            background: #2563eb;
        }
        
        .test-button.success {
            background: #10b981;
        }
        
        .test-button.warning {
            background: #f59e0b;
        }
        
        .test-button.danger {
            background: #ef4444;
        }
        
        .results {
            background: #1f2937;
            color: #f9fafb;
            padding: 16px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            margin-top: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .status {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status.success {
            background: #d1fae5;
            color: #065f46;
        }
        
        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }
        
        .status.warning {
            background: #fef3c7;
            color: #92400e;
        }
        
        .info-card {
            background: #e0f2fe;
            border-left: 4px solid #0ea5e9;
            padding: 16px;
            border-radius: 8px;
            margin: 12px 0;
        }
        
        .info-card h4 {
            margin: 0 0 8px 0;
            color: #0c4a6e;
        }
        
        .info-card p {
            margin: 0;
            color: #075985;
            font-size: 14px;
        }
        
        .period-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
            margin: 16px 0;
        }
        
        .period-card {
            background: #f8fafc;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            padding: 16px;
        }
        
        .period-card.current {
            border-color: #10b981;
            background: #ecfdf5;
        }
        
        .period-card.preparing {
            border-color: #3b82f6;
            background: #eff6ff;
        }
        
        .period-card.unlocked {
            border-color: #f59e0b;
            background: #fffbeb;
        }
        
        .period-card.archived {
            border-color: #6b7280;
            background: #f9fafb;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <div class="test-header">
            <h1 class="test-title">üéØ Testing: TemporalManager</h1>
            <span id="system-status" class="status">Verificando...</span>
        </div>
        
        <div class="info-card">
            <h4>üìã Objetivo del Testing</h4>
            <p>Verificar gesti√≥n de per√≠odos, navegaci√≥n temporal, clonaci√≥n, desbloqueo y activaci√≥n de per√≠odos.</p>
        </div>
        
        <div class="test-section">
            <div class="section-title">üîç 1. Verificaci√≥n de Sistema</div>
            <button class="test-button" onclick="checkSystemAvailability()">Verificar Disponibilidad</button>
            <button class="test-button" onclick="initializeManager()">Inicializar Manager</button>
            <button class="test-button" onclick="checkManagerState()">Estado del Manager</button>
        </div>
        
        <div class="test-section">
            <div class="section-title">üìÖ 2. Testing de Per√≠odos</div>
            <button class="test-button" onclick="listAllPeriods()">Listar Per√≠odos</button>
            <button class="test-button" onclick="showCurrentPeriod()">Per√≠odo Actual</button>
            <button class="test-button" onclick="checkPeriodsInfo()">Informaci√≥n Detallada</button>
        </div>
        
        <div class="test-section">
            <div class="section-title">üÜï 3. Testing de Creaci√≥n</div>
            <button class="test-button success" onclick="createFuturePeriod()">Crear Per√≠odo Futuro</button>
            <button class="test-button success" onclick="createPastPeriod()">Crear Per√≠odo Pasado</button>
            <button class="test-button warning" onclick="testCloning()">Testing Clonaci√≥n</button>
        </div>
        
        <div class="test-section">
            <div class="section-title">üîÑ 4. Testing de Navegaci√≥n</div>
            <button class="test-button" onclick="testPeriodSwitch()">Cambiar Entre Per√≠odos</button>
            <button class="test-button" onclick="testNavigationCallbacks()">Callbacks de Navegaci√≥n</button>
            <button class="test-button" onclick="testPeriodValidation()">Validaci√≥n de Per√≠odos</button>
        </div>
        
        <div class="test-section">
            <div class="section-title">üîì 5. Testing de Desbloqueo</div>
            <button class="test-button warning" onclick="testUnlockPeriod()">Desbloquear Per√≠odo</button>
            <button class="test-button" onclick="testLockPeriod()">Re-bloquear Per√≠odo</button>
            <button class="test-button" onclick="testUnlockLimits()">L√≠mites de Desbloqueo</button>
        </div>
        
        <div class="test-section">
            <div class="section-title">‚úÖ 6. Testing de Activaci√≥n</div>
            <button class="test-button success" onclick="testActivatePeriod()">Activar Per√≠odo</button>
            <button class="test-button" onclick="testActivationFlow()">Flujo Completo</button>
            <button class="test-button" onclick="testMonthDetection()">Detecci√≥n de Mes</button>
        </div>
        
        <div class="test-section">
            <div class="section-title">üß™ 7. Testing Avanzado</div>
            <button class="test-button" onclick="testEventSystem()">Sistema de Eventos</button>
            <button class="test-button" onclick="testErrorScenarios()">Escenarios de Error</button>
            <button class="test-button danger" onclick="stressTest()">‚ö° Stress Test</button>
        </div>
        
        <div id="periods-display" class="period-grid">
            <!-- Los per√≠odos se mostrar√°n aqu√≠ -->
        </div>
        
        <div id="results" class="results">üìù Consola de Testing - Los resultados aparecer√°n aqu√≠...\n</div>
    </div>

    <!-- Cargar TemporalStorage y TemporalManager -->
    <script src="js/temporal-storage.js"></script>
    <script src="js/temporal-manager.js"></script>
    
    <script>
        let temporalManager = null;
        let testResults = [];
        let eventLog = [];
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const formattedMessage = `[${timestamp}] ${message}`;
            testResults.push(formattedMessage);
            
            const resultsEl = document.getElementById('results');
            resultsEl.textContent += formattedMessage + '\n';
            resultsEl.scrollTop = resultsEl.scrollHeight;
            
            console.log(formattedMessage);
        }
        
        function updateStatus(status, type = 'success') {
            const statusEl = document.getElementById('system-status');
            statusEl.textContent = status;
            statusEl.className = `status ${type}`;
        }
        
        function updatePeriodsDisplay() {
            if (!temporalManager) return;
            
            const periodsInfo = temporalManager.getPeriodsInfo();
            const displayEl = document.getElementById('periods-display');
            
            displayEl.innerHTML = periodsInfo.map(period => `
                <div class="period-card ${period.state} ${period.isCurrent ? 'current' : ''}">
                    <h4>${period.displayName}</h4>
                    <p><strong>Estado:</strong> ${period.state}</p>
                    <p><strong>Editable:</strong> ${period.isEditable ? 'S√≠' : 'No'}</p>
                    <p><strong>Actual:</strong> ${period.isCurrent ? 'S√≠' : 'No'}</p>
                    <div style="margin-top: 8px; font-size: 12px;">
                        ${period.canActivate ? '‚úÖ Puede activar' : ''}
                        ${period.canUnlock ? 'üîì Puede desbloquear' : ''}
                        ${period.canSwitch ? 'üîÑ Puede cambiar' : ''}
                    </div>
                </div>
            `).join('');
        }
        
        // 1. VERIFICACI√ìN DE SISTEMA
        function checkSystemAvailability() {
            log('üîç Verificando disponibilidad del sistema...');
            
            try {
                if (typeof TemporalStorage !== 'undefined') {
                    log('‚úÖ TemporalStorage est√° disponible');
                } else {
                    log('‚ùå TemporalStorage NO est√° disponible');
                    updateStatus('TemporalStorage Faltante', 'error');
                    return;
                }
                
                if (typeof TemporalManager !== 'undefined') {
                    log('‚úÖ TemporalManager est√° disponible');
                    updateStatus('Sistemas Disponibles', 'success');
                } else {
                    log('‚ùå TemporalManager NO est√° disponible');
                    updateStatus('TemporalManager Faltante', 'error');
                    return;
                }
                
            } catch (error) {
                log(`‚ùå Error verificando sistema: ${error.message}`);
                updateStatus('Error de Sistema', 'error');
            }
        }
        
        async function initializeManager() {
            log('üéØ Inicializando TemporalManager...');
            
            try {
                temporalManager = new TemporalManager();
                
                // Esperar a que se inicialice
                let attempts = 0;
                while (!temporalManager.isInitialized && attempts < 20) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }
                
                if (temporalManager.isInitialized) {
                    log('‚úÖ TemporalManager inicializado correctamente');
                    updateStatus('Manager Activo', 'success');
                    updatePeriodsDisplay();
                } else {
                    log('‚ùå TemporalManager no se pudo inicializar');
                    updateStatus('Error de Inicializaci√≥n', 'error');
                }
                
            } catch (error) {
                log(`‚ùå Error inicializando manager: ${error.message}`);
                updateStatus('Error de Manager', 'error');
            }
        }
        
        function checkManagerState() {
            log('üîç Verificando estado del manager...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const state = temporalManager.getSystemState();
                
                log(`‚úÖ Manager inicializado: ${state.isInitialized}`);
                log(`üìÖ Per√≠odo activo: ${state.currentActivePeriod}`);
                log(`üìä Total per√≠odos: ${state.totalPeriods}`);
                log(`‚öôÔ∏è Configuraci√≥n: ${JSON.stringify(state.config)}`);
                
                updatePeriodsDisplay();
                
            } catch (error) {
                log(`‚ùå Error verificando estado: ${error.message}`);
            }
        }
        
        // 2. TESTING DE PER√çODOS
        function listAllPeriods() {
            log('üìÖ Listando todos los per√≠odos...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const periodsInfo = temporalManager.getPeriodsInfo();
                
                log(`üìä Total de per√≠odos: ${periodsInfo.length}`);
                
                periodsInfo.forEach(period => {
                    const indicators = [];
                    if (period.isCurrent) indicators.push('ACTUAL');
                    if (period.isEditable) indicators.push('EDITABLE');
                    if (period.canActivate) indicators.push('PUEDE_ACTIVAR');
                    if (period.canUnlock) indicators.push('PUEDE_DESBLOQUEAR');
                    
                    log(`   üìÜ ${period.period} (${period.displayName}): ${period.state.toUpperCase()} ${indicators.join(' ')}`);
                });
                
                updatePeriodsDisplay();
                
            } catch (error) {
                log(`‚ùå Error listando per√≠odos: ${error.message}`);
            }
        }
        
        function showCurrentPeriod() {
            log('üìÖ Mostrando per√≠odo actual...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const currentPeriod = temporalManager.currentActivePeriod;
                const displayName = temporalManager.formatPeriodDisplay(currentPeriod);
                const state = temporalManager.temporalStorage.getPeriodState(currentPeriod);
                const isEditable = temporalManager.temporalStorage.isPeriodEditable(currentPeriod);
                
                log(`üìÖ Per√≠odo actual: ${currentPeriod}`);
                log(`üè∑Ô∏è Nombre mostrado: ${displayName}`);
                log(`üéØ Estado: ${state}`);
                log(`‚úèÔ∏è Editable: ${isEditable ? 'S√≠' : 'No'}`);
                
                // Verificar datos del per√≠odo actual
                const allData = temporalManager.temporalStorage.getAllPeriodData(currentPeriod);
                log(`üìä Tipos de datos en per√≠odo actual: ${Object.keys(allData).length}`);
                
            } catch (error) {
                log(`‚ùå Error mostrando per√≠odo actual: ${error.message}`);
            }
        }
        
        function checkPeriodsInfo() {
            log('üîç Verificando informaci√≥n detallada de per√≠odos...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const systemState = temporalManager.getSystemState();
                const temporalInfo = systemState.temporalInfo;
                
                log('üìä INFORMACI√ìN DEL SISTEMA TEMPORAL:');
                log(`   üïê Per√≠odo actual: ${temporalInfo.currentPeriod}`);
                log(`   üìà Total per√≠odos: ${temporalInfo.totalPeriods}`);
                log(`   üîÑ Auto-guardado activo: ${temporalInfo.autoSaveActive ? 'S√≠' : 'No'}`);
                
                log('üìä ESTADOS DE PER√çODOS:');
                Object.entries(temporalInfo.periodStates).forEach(([period, info]) => {
                    log(`   üìÜ ${period}:`);
                    log(`      Estado: ${info.state}`);
                    log(`      Editable: ${info.isEditable ? 'S√≠' : 'No'}`);
                    log(`      Integridad: ${info.dataIntegrity.isValid ? 'V√°lida' : 'Inv√°lida'}`);
                });
                
            } catch (error) {
                log(`‚ùå Error verificando informaci√≥n: ${error.message}`);
            }
        }
        
        // 3. TESTING DE CREACI√ìN
        async function createFuturePeriod() {
            log('üÜï Creando per√≠odo futuro...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // Crear per√≠odo 2 meses en el futuro
                const futureDate = new Date();
                futureDate.setMonth(futureDate.getMonth() + 2);
                const futurePeriod = temporalManager.formatPeriod(futureDate);
                
                log(`üéØ Creando per√≠odo: ${futurePeriod}`);
                
                const success = await temporalManager.createNewPeriod(futurePeriod);
                
                if (success) {
                    log(`‚úÖ Per√≠odo ${futurePeriod} creado exitosamente`);
                    const displayName = temporalManager.formatPeriodDisplay(futurePeriod);
                    log(`üìÖ Nombre: ${displayName}`);
                    
                    updatePeriodsDisplay();
                } else {
                    log(`‚ùå Error creando per√≠odo ${futurePeriod}`);
                }
                
            } catch (error) {
                log(`‚ùå Error en creaci√≥n de per√≠odo futuro: ${error.message}`);
            }
        }
        
        async function createPastPeriod() {
            log('üÜï Creando per√≠odo pasado...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // Crear per√≠odo 1 mes en el pasado
                const pastDate = new Date();
                pastDate.setMonth(pastDate.getMonth() - 1);
                const pastPeriod = temporalManager.formatPeriod(pastDate);
                
                log(`üéØ Creando per√≠odo: ${pastPeriod}`);
                
                const success = await temporalManager.createNewPeriod(pastPeriod);
                
                if (success) {
                    log(`‚úÖ Per√≠odo ${pastPeriod} creado exitosamente`);
                    
                    // Verificar que se cre√≥ como archivado autom√°ticamente
                    const state = temporalManager.temporalStorage.getPeriodState(pastPeriod);
                    log(`üìã Estado autom√°tico: ${state}`);
                    
                    updatePeriodsDisplay();
                } else {
                    log(`‚ùå Error creando per√≠odo ${pastPeriod}`);
                }
                
            } catch (error) {
                log(`‚ùå Error en creaci√≥n de per√≠odo pasado: ${error.message}`);
            }
        }
        
        async function testCloning() {
            log('üß™ Testing clonaci√≥n de per√≠odos...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const sourcePeriod = temporalManager.currentActivePeriod;
                const targetPeriod = '2025_10'; // Per√≠odo de prueba
                
                log(`üîÑ Clonando ${sourcePeriod} ‚Üí ${targetPeriod}`);
                
                // Verificar datos del per√≠odo fuente
                const sourceData = temporalManager.temporalStorage.getAllPeriodData(sourcePeriod);
                log(`üìä Datos fuente: ${Object.keys(sourceData).length} tipos`);
                
                // Ejecutar clonaci√≥n
                const cloneSuccess = temporalManager.temporalStorage.clonePeriod(sourcePeriod, targetPeriod);
                
                if (cloneSuccess) {
                    log(`‚úÖ Clonaci√≥n exitosa`);
                    
                    // Verificar datos clonados
                    const clonedData = temporalManager.temporalStorage.getAllPeriodData(targetPeriod);
                    log(`üìä Datos clonados: ${Object.keys(clonedData).length} tipos`);
                    
                    // Verificar que los datos son iguales pero independientes
                    if (sourceData.ingresos && clonedData.ingresos) {
                        const sourceTotal = sourceData.ingresos.total;
                        const clonedTotal = clonedData.ingresos.total;
                        log(`üí∞ Ingresos fuente: ${sourceTotal?.toLocaleString('es-CL') || 'N/A'}`);
                        log(`üí∞ Ingresos clonados: ${clonedTotal?.toLocaleString('es-CL') || 'N/A'}`);
                        log(`üîç Integridad: ${sourceTotal === clonedTotal ? 'OK' : 'FAIL'}`);
                    }
                    
                    updatePeriodsDisplay();
                } else {
                    log(`‚ùå Error en clonaci√≥n`);
                }
                
            } catch (error) {
                log(`‚ùå Error en testing de clonaci√≥n: ${error.message}`);
            }
        }
        
        // 4. TESTING DE NAVEGACI√ìN
        async function testPeriodSwitch() {
            log('üîÑ Testing cambio entre per√≠odos...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const periodsInfo = temporalManager.getPeriodsInfo();
                const currentPeriod = temporalManager.currentActivePeriod;
                
                // Encontrar un per√≠odo diferente al actual
                const otherPeriod = periodsInfo.find(p => p.period !== currentPeriod && p.canSwitch);
                
                if (!otherPeriod) {
                    log('‚ö†Ô∏è No hay per√≠odos disponibles para cambio');
                    return;
                }
                
                log(`üéØ Cambiando de ${currentPeriod} a ${otherPeriod.period}`);
                
                const success = await temporalManager.switchToPeriod(otherPeriod.period);
                
                if (success) {
                    log(`‚úÖ Cambio exitoso a ${otherPeriod.period}`);
                    
                    // Verificar que el per√≠odo actual cambi√≥
                    const newCurrentPeriod = temporalManager.currentActivePeriod;
                    log(`üìÖ Nuevo per√≠odo actual: ${newCurrentPeriod}`);
                    
                    updatePeriodsDisplay();
                    
                    // Cambiar de vuelta
                    setTimeout(async () => {
                        log(`üîÑ Cambiando de vuelta a ${currentPeriod}`);
                        const backSuccess = await temporalManager.switchToPeriod(currentPeriod);
                        if (backSuccess) {
                            log(`‚úÖ Vuelta exitosa a ${currentPeriod}`);
                            updatePeriodsDisplay();
                        }
                    }, 1000);
                    
                } else {
                    log(`‚ùå Error cambiando a ${otherPeriod.period}`);
                }
                
            } catch (error) {
                log(`‚ùå Error en testing de navegaci√≥n: ${error.message}`);
            }
        }
        
        function testNavigationCallbacks() {
            log('üß™ Testing callbacks de navegaci√≥n...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // Registrar callback de prueba
                temporalManager.registerNavigationCallback('testCallback', (targetPeriod) => {
                    log(`üìã Callback ejecutado para per√≠odo: ${targetPeriod}`);
                    return Promise.resolve();
                });
                
                log('‚úÖ Callback de prueba registrado');
                
                // Verificar que est√° registrado
                const callbackCount = temporalManager.navigationCallbacks.size;
                log(`üìä Total callbacks: ${callbackCount}`);
                
                // Remover callback
                temporalManager.removeNavigationCallback('testCallback');
                log('‚úÖ Callback removido');
                
            } catch (error) {
                log(`‚ùå Error en testing de callbacks: ${error.message}`);
            }
        }
        
        function testPeriodValidation() {
            log('üß™ Testing validaci√≥n de per√≠odos...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const periodsInfo = temporalManager.getPeriodsInfo();
                
                periodsInfo.forEach(period => {
                    const exists = temporalManager.periodExists(period.period);
                    const validation = temporalManager.temporalStorage.validatePeriodData(period.period);
                    
                    log(`üîç ${period.period}:`);
                    log(`   Existe: ${exists ? 'S√≠' : 'No'}`);
                    log(`   V√°lido: ${validation.isValid ? 'S√≠' : 'No'}`);
                    
                    if (!validation.isValid) {
                        validation.issues.forEach(issue => {
                            log(`   ‚ö†Ô∏è ${issue}`);
                        });
                    }
                });
                
            } catch (error) {
                log(`‚ùå Error en validaci√≥n: ${error.message}`);
            }
        }
        
        // 5. TESTING DE DESBLOQUEO
        async function testUnlockPeriod() {
            log('üîì Testing desbloqueo de per√≠odo...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const periodsInfo = temporalManager.getPeriodsInfo();
                const archivedPeriod = periodsInfo.find(p => p.canUnlock);
                
                if (!archivedPeriod) {
                    log('‚ö†Ô∏è No hay per√≠odos archivados para desbloquear');
                    
                    // Crear y archivar un per√≠odo para testing
                    const testPeriod = '2025_06';
                    await temporalManager.createNewPeriod(testPeriod);
                    temporalManager.temporalStorage.setPeriodState(testPeriod, 'archived');
                    log(`üì¶ Per√≠odo de prueba ${testPeriod} creado y archivado`);
                    updatePeriodsDisplay();
                    
                    // Intentar desbloquear el per√≠odo de prueba
                    const unlockSuccess = await temporalManager.unlockPeriod(testPeriod);
                    
                    if (unlockSuccess) {
                        log(`‚úÖ Per√≠odo ${testPeriod} desbloqueado exitosamente`);
                        
                        // Verificar estado
                        const state = temporalManager.temporalStorage.getPeriodState(testPeriod);
                        log(`üìã Nuevo estado: ${state}`);
                        
                        updatePeriodsDisplay();
                    } else {
                        log(`‚ùå Error desbloqueando per√≠odo ${testPeriod}`);
                    }
                    
                    return;
                }
                
                log(`üéØ Desbloqueando per√≠odo: ${archivedPeriod.period}`);
                
                const unlockSuccess = await temporalManager.unlockPeriod(archivedPeriod.period);
                
                if (unlockSuccess) {
                    log(`‚úÖ Per√≠odo ${archivedPeriod.period} desbloqueado exitosamente`);
                    
                    // Verificar que el auto-guardado se activ√≥
                    const temporalInfo = temporalManager.temporalStorage.getTemporalInfo();
                    log(`üîÑ Auto-guardado activo: ${temporalInfo.autoSaveActive ? 'S√≠' : 'No'}`);
                    
                    updatePeriodsDisplay();
                } else {
                    log(`‚ùå Error desbloqueando per√≠odo ${archivedPeriod.period}`);
                }
                
            } catch (error) {
                log(`‚ùå Error en testing de desbloqueo: ${error.message}`);
            }
        }
        
        async function testLockPeriod() {
            log('üîí Testing re-bloqueo de per√≠odo...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const periodsInfo = temporalManager.getPeriodsInfo();
                const unlockedPeriod = periodsInfo.find(p => p.state === 'unlocked');
                
                if (!unlockedPeriod) {
                    log('‚ö†Ô∏è No hay per√≠odos desbloqueados para re-bloquear');
                    return;
                }
                
                log(`üéØ Re-bloqueando per√≠odo: ${unlockedPeriod.period}`);
                
                const lockSuccess = await temporalManager.lockPeriod(unlockedPeriod.period);
                
                if (lockSuccess) {
                    log(`‚úÖ Per√≠odo ${unlockedPeriod.period} re-bloqueado exitosamente`);
                    
                    // Verificar estado
                    const state = temporalManager.temporalStorage.getPeriodState(unlockedPeriod.period);
                    log(`üìã Nuevo estado: ${state}`);
                    
                    updatePeriodsDisplay();
                } else {
                    log(`‚ùå Error re-bloqueando per√≠odo ${unlockedPeriod.period}`);
                }
                
            } catch (error) {
                log(`‚ùå Error en testing de re-bloqueo: ${error.message}`);
            }
        }
        
        async function testUnlockLimits() {
            log('üß™ Testing l√≠mites de desbloqueo...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // Verificar l√≠mite actual
                const canUnlock = temporalManager.validateUnlockLimit();
                log(`üîç Puede desbloquear m√°s per√≠odos: ${canUnlock ? 'S√≠' : 'No'}`);
                
                // Contar per√≠odos desbloqueados
                const periodsInfo = temporalManager.getPeriodsInfo();
                const unlockedCount = periodsInfo.filter(p => p.state === 'unlocked').length;
                const maxUnlocked = temporalManager.config.maxUnlockedPeriods;
                
                log(`üìä Per√≠odos desbloqueados: ${unlockedCount}/${maxUnlocked}`);
                
                if (unlockedCount >= maxUnlocked) {
                    log('‚ö†Ô∏è L√≠mite de desbloqueo alcanzado');
                    
                    // Intentar desbloquear otro (deber√≠a fallar)
                    const archivedPeriod = periodsInfo.find(p => p.state === 'archived');
                    if (archivedPeriod) {
                        log(`üß™ Intentando desbloquear ${archivedPeriod.period} (deber√≠a fallar)`);
                        const unlockResult = await temporalManager.unlockPeriod(archivedPeriod.period);
                        log(`üìã Resultado: ${unlockResult ? '√âxito (ERROR!)' : 'Fall√≥ (correcto)'}`);
                    }
                } else {
                    log('‚úÖ Hay espacio para m√°s desbloqueos');
                }
                
            } catch (error) {
                log(`‚ùå Error en testing de l√≠mites: ${error.message}`);
            }
        }
        
        // 6. TESTING DE ACTIVACI√ìN
        async function testActivatePeriod() {
            log('‚úÖ Testing activaci√≥n de per√≠odo...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const periodsInfo = temporalManager.getPeriodsInfo();
                const preparingPeriod = periodsInfo.find(p => p.canActivate);
                
                if (!preparingPeriod) {
                    log('‚ö†Ô∏è No hay per√≠odos en preparaci√≥n para activar');
                    
                    // Crear per√≠odo en preparaci√≥n para testing
                    const testPeriod = '2025_11';
                    await temporalManager.createNewPeriod(testPeriod);
                    log(`üì¶ Per√≠odo de prueba ${testPeriod} creado en preparaci√≥n`);
                    updatePeriodsDisplay();
                    
                    // Intentar activar
                    const activateSuccess = await temporalManager.activatePeriod(testPeriod);
                    
                    if (activateSuccess) {
                        log(`‚úÖ Per√≠odo ${testPeriod} activado exitosamente`);
                        
                        // Verificar que es el nuevo per√≠odo actual
                        const newCurrentPeriod = temporalManager.currentActivePeriod;
                        log(`üìÖ Nuevo per√≠odo actual: ${newCurrentPeriod}`);
                        
                        updatePeriodsDisplay();
                    } else {
                        log(`‚ùå Error activando per√≠odo ${testPeriod}`);
                    }
                    
                    return;
                }
                
                const currentPeriod = temporalManager.currentActivePeriod;
                log(`üéØ Activando per√≠odo: ${preparingPeriod.period}`);
                log(`üìÖ Per√≠odo actual que ser√° archivado: ${currentPeriod}`);
                
                const activateSuccess = await temporalManager.activatePeriod(preparingPeriod.period);
                
                if (activateSuccess) {
                    log(`‚úÖ Per√≠odo ${preparingPeriod.period} activado exitosamente`);
                    
                    // Verificar cambios
                    const newCurrentPeriod = temporalManager.currentActivePeriod;
                    const oldPeriodState = temporalManager.temporalStorage.getPeriodState(currentPeriod);
                    
                    log(`üìÖ Nuevo per√≠odo actual: ${newCurrentPeriod}`);
                    log(`üìã Estado del per√≠odo anterior: ${oldPeriodState}`);
                    
                    updatePeriodsDisplay();
                } else {
                    log(`‚ùå Error activando per√≠odo ${preparingPeriod.period}`);
                }
                
            } catch (error) {
                log(`‚ùå Error en testing de activaci√≥n: ${error.message}`);
            }
        }
        
        async function testActivationFlow() {
            log('üß™ Testing flujo completo de activaci√≥n...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const originalPeriod = temporalManager.currentActivePeriod;
                log(`üìÖ Per√≠odo original: ${originalPeriod}`);
                
                // 1. Crear nuevo per√≠odo
                const newPeriod = '2025_12';
                log(`üÜï Paso 1: Creando per√≠odo ${newPeriod}`);
                
                const createSuccess = await temporalManager.createNewPeriod(newPeriod);
                if (!createSuccess) {
                    log('‚ùå Error en paso 1: Creaci√≥n fallida');
                    return;
                }
                
                // 2. Verificar que est√° en preparaci√≥n
                const state = temporalManager.temporalStorage.getPeriodState(newPeriod);
                log(`üìã Paso 2: Estado del nuevo per√≠odo: ${state}`);
                
                // 3. Activar per√≠odo
                log(`‚úÖ Paso 3: Activando per√≠odo ${newPeriod}`);
                const activateSuccess = await temporalManager.activatePeriod(newPeriod);
                
                if (activateSuccess) {
                    log(`‚úÖ Flujo completo exitoso`);
                    
                    // 4. Verificar resultado final
                    const finalCurrentPeriod = temporalManager.currentActivePeriod;
                    const originalState = temporalManager.temporalStorage.getPeriodState(originalPeriod);
                    
                    log(`üìä RESULTADO FINAL:`);
                    log(`   Per√≠odo actual: ${finalCurrentPeriod}`);
                    log(`   Per√≠odo original archivado: ${originalState === 'archived' ? 'S√≠' : 'No'}`);
                    
                    updatePeriodsDisplay();
                } else {
                    log('‚ùå Error en paso 3: Activaci√≥n fallida');
                }
                
            } catch (error) {
                log(`‚ùå Error en flujo de activaci√≥n: ${error.message}`);
            }
        }
        
        function testMonthDetection() {
            log('üß™ Testing detecci√≥n de cambio de mes...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // Simular cambio de mes
                const currentPeriod = temporalManager.currentActivePeriod;
                const realCurrentPeriod = temporalManager.temporalStorage.getCurrentPeriod();
                
                log(`üìÖ Per√≠odo activo en manager: ${currentPeriod}`);
                log(`üìÖ Per√≠odo real actual: ${realCurrentPeriod}`);
                
                if (currentPeriod !== realCurrentPeriod) {
                    log('üîç Cambio de mes detectado por diferencia');
                    temporalManager.handleMonthChange(realCurrentPeriod);
                } else {
                    log('‚úÖ Per√≠odos sincronizados, no hay cambio de mes');
                }
                
                // Verificar configuraci√≥n de detecci√≥n
                log('‚öôÔ∏è Sistema de detecci√≥n configurado correctamente');
                
            } catch (error) {
                log(`‚ùå Error en testing de detecci√≥n: ${error.message}`);
            }
        }
        
        // 7. TESTING AVANZADO
        function testEventSystem() {
            log('üß™ Testing sistema de eventos...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // Setup listeners de prueba
                const eventTypes = [
                    'temporalPeriodChanged',
                    'temporalPeriodCreated',
                    'temporalPeriodActivated',
                    'temporalPeriodUnlocked',
                    'temporalPeriodLocked'
                ];
                
                eventTypes.forEach(eventType => {
                    window.addEventListener(eventType, (e) => {
                        eventLog.push({
                            type: eventType,
                            detail: e.detail,
                            timestamp: new Date().toISOString()
                        });
                        log(`üì¢ Evento recibido: ${eventType}`);
                    });
                });
                
                log('‚úÖ Listeners de eventos configurados');
                log(`üìä Total tipos de eventos monitoreados: ${eventTypes.length}`);
                
                // Disparar evento de prueba
                temporalManager.dispatchPeriodChangeEvent('test_period');
                
                setTimeout(() => {
                    log(`üìä Eventos capturados: ${eventLog.length}`);
                    eventLog.forEach(event => {
                        log(`   üì¢ ${event.type}: ${JSON.stringify(event.detail)}`);
                    });
                }, 100);
                
            } catch (error) {
                log(`‚ùå Error en testing de eventos: ${error.message}`);
            }
        }
        
        async function testErrorScenarios() {
            log('üß™ Testing escenarios de error...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                // 1. Per√≠odo inexistente
                log('üß™ Test 1: Cambiar a per√≠odo inexistente');
                const invalidSwitch = await temporalManager.switchToPeriod('invalid_period');
                log(`üìã Resultado: ${invalidSwitch ? '√âxito (ERROR!)' : 'Fall√≥ (correcto)'}`);
                
                // 2. Crear per√≠odo duplicado
                log('üß™ Test 2: Crear per√≠odo duplicado');
                const currentPeriod = temporalManager.currentActivePeriod;
                const duplicateCreate = await temporalManager.createNewPeriod(currentPeriod);
                log(`üìã Resultado: ${duplicateCreate ? '√âxito (ERROR!)' : 'Fall√≥ (correcto)'}`);
                
                // 3. Activar per√≠odo no v√°lido
                log('üß™ Test 3: Activar per√≠odo archivado');
                const periodsInfo = temporalManager.getPeriodsInfo();
                const archivedPeriod = periodsInfo.find(p => p.state === 'archived');
                if (archivedPeriod) {
                    const invalidActivate = await temporalManager.activatePeriod(archivedPeriod.period);
                    log(`üìã Resultado: ${invalidActivate ? '√âxito (ERROR!)' : 'Fall√≥ (correcto)'}`);
                }
                
                // 4. Desbloquear per√≠odo ya desbloqueado
                log('üß™ Test 4: Desbloquear per√≠odo activo');
                const invalidUnlock = await temporalManager.unlockPeriod(currentPeriod);
                log(`üìã Resultado: ${invalidUnlock ? '√âxito (ERROR!)' : 'Fall√≥ (correcto)'}`);
                
                log('‚úÖ Testing de errores completado');
                
            } catch (error) {
                log(`‚ùå Error en testing de errores: ${error.message}`);
            }
        }
        
        async function stressTest() {
            log('‚ö° Iniciando stress test...');
            
            if (!temporalManager) {
                log('‚ùå TemporalManager no est√° inicializado');
                return;
            }
            
            try {
                const startTime = performance.now();
                
                // 1. Crear m√∫ltiples per√≠odos r√°pidamente
                log('‚ö° Test 1: Creaci√≥n masiva de per√≠odos');
                const createPromises = [];
                for (let i = 1; i <= 5; i++) {
                    const testPeriod = `2026_${String(i).padStart(2, '0')}`;
                    createPromises.push(temporalManager.createNewPeriod(testPeriod));
                }
                
                const createResults = await Promise.all(createPromises);
                const successfulCreates = createResults.filter(r => r).length;
                log(`üìä Per√≠odos creados: ${successfulCreates}/${createPromises.length}`);
                
                // 2. Operaciones r√°pidas de estado
                log('‚ö° Test 2: Cambios de estado r√°pidos');
                const periodsInfo = temporalManager.getPeriodsInfo();
                let stateChanges = 0;
                
                periodsInfo.forEach(period => {
                    if (period.period.startsWith('2026_')) {
                        temporalManager.temporalStorage.setPeriodState(period.period, 'archived');
                        temporalManager.temporalStorage.setPeriodState(period.period, 'preparing');
                        stateChanges += 2;
                    }
                });
                
                log(`üìä Cambios de estado: ${stateChanges}`);
                
                // 3. Lectura masiva de datos
                log('‚ö° Test 3: Lectura masiva de datos');
                let dataReads = 0;
                periodsInfo.forEach(period => {
                    const allData = temporalManager.temporalStorage.getAllPeriodData(period.period);
                    dataReads += Object.keys(allData).length;
                });
                
                log(`üìä Lecturas de datos: ${dataReads}`);
                
                const endTime = performance.now();
                const totalTime = endTime - startTime;
                
                log(`‚úÖ Stress test completado en ${totalTime.toFixed(2)}ms`);
                
                updatePeriodsDisplay();
                
            } catch (error) {
                log(`‚ùå Error en stress test: ${error.message}`);
            }
        }
        
        // Configurar eventos del sistema
        function setupEventListeners() {
            const eventTypes = [
                'temporalPeriodChanged',
                'temporalPeriodCreated', 
                'temporalPeriodActivated',
                'temporalPeriodUnlocked',
                'temporalPeriodLocked',
                'temporalMonthChangeDetected',
                'temporalNavigationError',
                'temporalCreationError'
            ];
            
            eventTypes.forEach(eventType => {
                window.addEventListener(eventType, (e) => {
                    log(`üì¢ Evento: ${eventType} - ${JSON.stringify(e.detail)}`);
                    updatePeriodsDisplay();
                });
            });
        }
        
        // Verificaci√≥n inicial al cargar la p√°gina
        window.addEventListener('load', () => {
            setTimeout(() => {
                log('üöÄ Testing de TemporalManager iniciado');
                log('üìã Haz clic en los botones para ejecutar las pruebas');
                log('‚ö†Ô∏è Aseg√∫rate de ejecutar primero "Verificar Disponibilidad" e "Inicializar Manager"');
                log('');
                
                setupEventListeners();
                checkSystemAvailability();
            }, 500);
        });
    </script>
</body>
</html>